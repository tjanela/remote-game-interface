package com.blissapplications.as3 {		import flash.net.Socket;	import flash.utils.Timer;	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.utils.ByteArray;	import com.junkbyte.console.Cc;		public class RemoteGameInterfaceSocket extends Socket {				private var _incomingPacket:ByteArray;				public function RemoteGameInterfaceSocket() {			configureListeners();			_incomingPacket = new ByteArray();		}				public function configureListeners():void{			addEventListener(Event.CLOSE, socketCloseHandler);			addEventListener(Event.CONNECT, socketConnectHandler);			addEventListener(IOErrorEvent.IO_ERROR, socketIOErrorHandler);			addEventListener(ProgressEvent.SOCKET_DATA, socketDataHandler);			addEventListener(SecurityErrorEvent.SECURITY_ERROR, socketSecurityErrorHandler);		}				public function socketConnectHandler(e:Event):void{			Cc.log("Connected to Remote Interface Server server! Sending REQUEST_REGISTER_DISPLAY_CLIENT packet...");			var packet:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_REGISTER_DISPLAY_CLIENT);			packet.sendToSocket(this);		}				public function socketCloseHandler(e:Event):void{			Cc.log("Server closed the connection.");		}				public function socketDataHandler(e:ProgressEvent):void{									var bytesAvailable:int = this.bytesAvailable;			Cc.log("Reading " + bytesAvailable + " bytes from socket...");			this.readBytes(_incomingPacket,0,bytesAvailable);						Cc.log("Current packet is: " + _incomingPacket);						if(_incomingPacket.length >= RemoteGameInterfacePacket.PACKET_MIN_SIZE){				var previousPosition:int = _incomingPacket.position;				_incomingPacket.position = 0;				var possiblePacket:RemoteGameInterfacePacket = tryToDecodePacket(_incomingPacket);				if(possiblePacket != null){					//Invoke delegate with packet.					//trim _incomingPacket					var newIncomingPacket:ByteArray = new ByteArray();					newIncomingPacket.writeBytes(_incomingPacket,0, _incomingPacket.length - _incomingPacket.position);					_incomingPacket = newIncomingPacket;										Cc.log("Received packet: " + possiblePacket);									}else {					_incomingPacket.position = previousPosition;				}			}		}				public function tryToDecodePacket(possiblePacketByteArray:ByteArray):RemoteGameInterfacePacket{			var possiblePacket:RemoteGameInterfacePacket = null;						var ourMagic:ByteArray = new ByteArray();			ourMagic.writeMultiByte(RemoteGameInterfacePacket.MAGIC, "UTF-8");			while(possiblePacketByteArray.position <= possiblePacketByteArray.length - RemoteGameInterfacePacket.MAGIC_FIELD_LENGTH){				var position:int = possiblePacketByteArray.position;				var isMagic:Boolean = true;				var exit:Boolean = false;;				for(var i:int = 0 ; i < RemoteGameInterfacePacket.MAGIC_FIELD_LENGTH  && isMagic; i++){					isMagic &&= possiblePacketByteArray[position + i] == ourMagic[i];				}				if(isMagic){					var packetByteArray:ByteArray = new ByteArray();					Cc.log("Creating isolated packet with length " + (position + RemoteGameInterfacePacket.MAGIC_FIELD_LENGTH));					packetByteArray.writeBytes(possiblePacketByteArray,0,position + RemoteGameInterfacePacket.MAGIC_FIELD_LENGTH);					packetByteArray.position = 0;					possiblePacket = RemoteGameInterfacePacket.readFromByteArray(packetByteArray);					possiblePacketByteArray.position = position + RemoteGameInterfacePacket.MAGIC_FIELD_LENGTH;					break;				}				possiblePacketByteArray.position = position+1;			}						return possiblePacket;		}				/* Error handlers */		public function socketIOErrorHandler(e:IOErrorEvent):void {    	Cc.log("Error '" + e + "'. Giving up...");		}				public function socketSecurityErrorHandler(e:SecurityErrorEvent):void {    	Cc.log("Security Error '" + e + "'. Giving up...");		}	}	}