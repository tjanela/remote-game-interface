package com.blissapplications.as3 {	  import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.system.Security;  import flash.events.EventDispatcher;	import flash.events.Event;		import com.junkbyte.console.Cc;	import flash.utils.ByteArray;			public class RemoteGameInterface extends EventDispatcher implements IRemoteGameInterfaceSocketDelegate, IRemoteGameInterfacePolicyLoaderDelegate {		public static var STATE_DISCONNECTED:String = "RGI:STATE_DISCONNECTED"; 		public static var STATE_CONNECTED:String 		= "RGI:STATE_CONNECTED"; 		public static var STATE_REGISTERED:String 	= "RGI:STATE_REGISTERED"; 		public static var STATE_HANDSHAKED:String 	= "RGI:STATE_HANDSHAKED"; 		public static var STATE_ACTIVATED:String 		= "RGI:STATE_ACTIVATED"; 		public static var STATE_DEACTIVATED:String 	= "RGI:STATE_DEACTIVATED"; 				public static var ACTION_CONNECT:String = "RGI:ACTION_CONNECT";		public static var ACTION_REGISTER:String = "RGI:ACTION_REGISTER";		public static var ACTION_HANDSHAKE:String = "RGI:ACTION_HANDSHAKE";				//PopoDescida		public static var ACTION_ACTIVATE:String = "RGI:ACTION_ACTIVATE";		public static var ACTION_SCORE:String = "RGI:ACTION_SCORE";		public static var ACTION_CONTROL_DATA:String = "RGI:ACTION_CONTROL_DATA";		public static var ACTION_DEACTIVATE:String = "RGI:ACTION_DEACTIVATE";		public static var ACTION_REPLAY:String = "RGI:ACTION_REPLAY";		public static var ACTION_UNREGISTER:String = "RGI:ACTION_UNREGISTER";		public static var ACTION_DISCONNECT:String = "RGI:ACTION_DISCONNECT";				//PopoGraffiti		public static var ACTION_ACTIVATE_PAINT:String = "RGI:ACTION_ACTIVATE_PAINT";		public static var ACTION_DEACTIVATE_PAINT:String = "RGI:ACTION_EACTIVATE_PAINT";		public static var ACTION_CONTROL_DATA_PAINT:String = "RGI:ACTION_CONTROL_DATA_PAINT";		public static var ACTION_PAINT_FINAL:String = "RGI:ACTION_FINAL_PAINT";		var _state:String;		var _host:String;		var _port:int;		var _policyPort:int;				var _policyLoader:RemoteGameInterfacePolicyLoader;		var _socket:RemoteGameInterfaceSocket;		var _connectTimer:Timer;								var _hash:String;		public function RemoteGameInterface(host:String, port:int) {			_host = host;			_port = port;			_policyPort = 8080;			_policyLoader = new RemoteGameInterfacePolicyLoader();			_policyLoader.policyLoaderDelegate = this;		}				public function executeAction(action:String, data:Object = null):void{			Cc.log("Executing Action '" +action + "'...");			switch(action){				case ACTION_CONNECT:				{					connectToServer();					break;				}				case ACTION_REGISTER:				{					registerWithServer();					break;				}				case ACTION_HANDSHAKE:				{					respondToHandshake();					break;				}				case ACTION_ACTIVATE:				{					sendActivateToken();					dispatchActivate();					break;				}				case ACTION_ACTIVATE_PAINT:				{					sendActivatePaintToken();					dispatchActivatePaint();					break;				}				case ACTION_DEACTIVATE_PAINT:				{					Cc.log("executing Deactivate Paint");					dispatchDeactivatePaint();					break;				}				case ACTION_PAINT_FINAL:				{					sendFinal(String(data));					break;				}				case ACTION_SCORE:				{					sendScore( int(data));					break;				}				case ACTION_CONTROL_DATA:				{					dispatchControl(data);					break;				}				case ACTION_CONTROL_DATA_PAINT:				{					dispatchControlPaint(data);					break;				}				case ACTION_DEACTIVATE:				{					sendFinish(int(data));					break;				}				case ACTION_REPLAY:				{					dispatchReplay(data)					break;				}				case ACTION_UNREGISTER:				{					unregisterWithServer();					break;				}				case ACTION_DISCONNECT:				{					disconnectFromServer();					break;				}			}		}				public function policyError(policyLoader:RemoteGameInterfacePolicyLoader,e:Error):void{			var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.ERROR, e);			dispatchEvent(newEvent);		}				public function policyLoaded():void{			_socket = new RemoteGameInterfaceSocket();			_socket.socketDelegate = this;			try{				_socket.connect(_host,_port);				if(_connectTimer != null){					_connectTimer.stop();				}			}catch(e:Error){				Cc.log("Coulnd't connect. Error: '" + e + "'.");				var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.ERROR, e);			dispatchEvent(newEvent);			}		}				//Socket Connect and Policy stuff Hack				private function connectToServer(){			Cc.log("Connecting to Policy Server '" + _host + ":" + _policyPort + "'...");			_policyLoader.loadPolicy(_host, _policyPort);		}				private function disconnectFromServer(){			Cc.log("Disconnecting from Remote Interface Server...");						_socket.close();		}						private function resetState(){			Cc.log("Resetting state...");			disconnectFromServer();			_state = STATE_DISCONNECTED;		}		    private function completeHandler(e:TimerEvent):void {    	Cc.log("Couldn't connect to Remote Interface Server. Giving up...");		}				//RemoteGameInterfaceProtocol				private function registerWithServer():void{			var packet:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_REGISTER_DISPLAY_CLIENT);			_socket.sendPacket(packet);		}				private function unregisterWithServer():void{			var payload:ByteArray = new ByteArray();			payload.writeMultiByte(_hash,"UTF-8");			var packet:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_UNREGISTER_DISPLAY_CLIENT, payload);			_socket.sendPacket(packet);		}				private function respondToHandshake():void{			var handshake:ByteArray = new ByteArray();			handshake.writeMultiByte("OLEH","UTF-8");			var packet:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.RESPONSE_PAYLOAD, handshake);			packet.sendToSocket(_socket);		}				private function sendActivateToken():void{			sendScore(0);		}				private function sendActivatePaintToken():void{			var payload:ByteArray = new ByteArray();			payload.writeMultiByte("PAINT_OK","UTF-8");			var activateToken:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_PAYLOAD,payload);			activateToken.sendToSocket(_socket);		}				private function sendScore(score:int):void{			var payload:ByteArray = new ByteArray();			payload.writeMultiByte("SCORE:"+score,"UTF-8");			var activateToken:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_PAYLOAD,payload);			activateToken.sendToSocket(_socket);		}				private function dispatchActivate(){			dispatchEvent(new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.ACTIVATED));		}		private function dispatchActivatePaint(){			dispatchEvent(new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.PAINT_ACTIVATED));		}		private function dispatchDeactivatePaint(){			dispatchEvent(new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.PAINT_DEACTIVATED));		}		private function dispatchControl(data:Object):void{			var controlDataNormalized:Object = new Object();			var controlData:String = String(data);			controlData = controlData.replace("<CONTROL>","");			var controlProperties:Array = controlData.split("|");			for(var i = 0; i < controlProperties.length; i++){				var keyValue:Array = controlProperties[i].split(":");				controlDataNormalized[keyValue[0]] = keyValue[1];			}						var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.RECEIVED_CONTROL, controlDataNormalized);			dispatchEvent(newEvent);		}		private function dispatchControlPaint(data:Object):void{			var controlDataNormalized:Object = new Object();			var controlData:String = String(data);			controlData = controlData.replace("<CONTROL_PAINT>","");			var controlProperties:Array = controlData.split("|");			for(var i = 0; i < controlProperties.length; i++){				var keyValue:Array = controlProperties[i].split(":");				controlDataNormalized[keyValue[0]] = keyValue[1];			}						var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.RECEIVED_PAINT_CONTROL, controlDataNormalized);			dispatchEvent(newEvent);		}				private function dispatchReplay(data:Object):void{			var controlDataNormalized:Object = new Object();			var controlData:String = String(data);			var controlProperties:Array = controlData.split("|");			for(var i = 0; i < controlProperties.length; i++){				var keyValue:Array = controlProperties[i].split(":");				controlDataNormalized[keyValue[0]] = keyValue[1];			}						var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.RECEIVED_REPLAY, controlDataNormalized);			dispatchEvent(newEvent);		}				private function sendFinish(score:int){			var payload:ByteArray = new ByteArray();			payload.writeMultiByte("FINISH:"+score,"UTF-8");			var finishToken:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_PAYLOAD,payload);			finishToken.sendToSocket(_socket);		}				private function sendFinal(url:String)		{			//			var payload:ByteArray = new ByteArray();			payload.writeMultiByte("FINAL:"+url,"UTF-8");			var finishToken:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(RemoteGameInterfacePacket.REQUEST_PAYLOAD,payload);			finishToken.sendToSocket(_socket);			}				//IRemoteGameInterfaceSocketDelegate				public function socketError(socket:RemoteGameInterfaceSocket, err:Error):void{			var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.ERROR, err);			dispatchEvent(newEvent);		}				public function socketConnected(socket:RemoteGameInterfaceSocket):void{			Cc.log("Connected to Remote Interface Server server! Sending REQUEST_REGISTER_DISPLAY_CLIENT packet...");			var newEvent:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.CONNECTED);			dispatchEvent(newEvent);		}				public function socketDidReceivePacket(socket:RemoteGameInterfaceSocket, packet:RemoteGameInterfacePacket):void{			Cc.log("Received packet: " + packet);			if(packet._id == RemoteGameInterfacePacket.RESPONSE_REGISTER_DISPLAY_CLIENT){				var newEvent1:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.REGISTERED, packet._payload);				dispatchEvent(newEvent1);			}			else if(packet._id == RemoteGameInterfacePacket.RESPONSE_REGISTER_CONTROL_CLIENT){				var newEvent2:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.CONTROL_CLIENT_REGISTERED, packet._payload);				dispatchEvent(newEvent2);			}			else if(packet._id == RemoteGameInterfacePacket.REQUEST_UNREGISTER_DISPLAY_CLIENT){				var newEvent3:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.CONTROL_CLIENT_UNREGISTERED, packet._payload);				dispatchEvent(newEvent3);			}			else if(packet._id == RemoteGameInterfacePacket.REQUEST_PAYLOAD){				Cc.log("Received packet: " + packet._payload);				var payloadAsString:String = packet._payload.readMultiByte(packet._payload.length, "UTF-8");				Cc.log("Got Payload: " + payloadAsString);				if(payloadAsString == "HELO"){					executeAction(ACTION_HANDSHAKE,payloadAsString);					var newEvent4:RemoteGameInterfaceEvent = new RemoteGameInterfaceEvent(RemoteGameInterfaceEvent.HANDSHAKED, packet._payload);					dispatchEvent(newEvent4);				}					else if(payloadAsString.search("START") == 0){					executeAction(ACTION_ACTIVATE,payloadAsString);				}				else if(payloadAsString.search("<CONTROL>") == 0){					executeAction(ACTION_CONTROL_DATA,payloadAsString);				}				else if(payloadAsString.search("REPLAY:") == 0){					executeAction(ACTION_REPLAY,payloadAsString);				}				else if(payloadAsString.search("PAINT_END") == 0){					executeAction(ACTION_DEACTIVATE_PAINT,payloadAsString);				}				else if(payloadAsString.search("PAINT") == 0){					executeAction(ACTION_ACTIVATE_PAINT,payloadAsString);				}				else if(payloadAsString.search("<CONTROL_PAINT>") == 0){					executeAction(ACTION_CONTROL_DATA_PAINT,payloadAsString);				}			}		}			}	}