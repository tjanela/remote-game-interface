package com.blissapplications.as3 {	import flash.utils.ByteArray;	import flash.net.Socket;	import com.junkbyte.console.Cc;		public class RemoteGameInterfacePacket {				public static const REQUEST_REGISTER_DISPLAY_CLIENT:int = 0x010000;		public static const REQUEST_UNREGISTER_DISPLAY_CLIENT:int = 0x010001;		public static const RESPONSE_REGISTER_DISPLAY_CLIENT:int = 0x01FFFF;		public static const RESPONSE_UNREGISTER_DISPLAY_CLIENT:int = 0x01FFFE;				public static const REQUEST_REGISTER_CONTROL_CLIENT:int = 0x020000;		public static const REQUEST_UNREGISTER_CONTROL_CLIENT:int = 0x020001;		public static const RESPONSE_REGISTER_CONTROL_CLIENT:int = 0x02FFFF;		public static const RESPONSE_UNREGISTER_CONTROL_CLIENT:int = 0x02FFFE;				public static const REQUEST_PAYLOAD:int = 0x030000;		public static const RESPONSE_PAYLOAD:int = 0x03FFFF;				public static const UNKNOWN_PACKET:int = 0x000000;				public static const ID_FIELD_LENGTH:int = 3;				public static const MAGIC:String = "[!PUMP!]";		public static const MAGIC_FIELD_LENGTH:int = MAGIC.length;				public static const PACKET_MIN_SIZE:int = ID_FIELD_LENGTH + MAGIC_FIELD_LENGTH;				public static function nameOfPacket(id:int):String{			if(id == REQUEST_REGISTER_DISPLAY_CLIENT){				return "REQUEST_REGISTER_DISPLAY_CLIENT";			}else if(id == REQUEST_UNREGISTER_DISPLAY_CLIENT){				return "REQUEST_UNREGISTER_DISPLAY_CLIENT";			}else if(id == RESPONSE_REGISTER_DISPLAY_CLIENT){				return "RESPONSE_REGISTER_DISPLAY_CLIENT";			}else if(id == RESPONSE_UNREGISTER_DISPLAY_CLIENT){				return "RESPONSE_UNREGISTER_DISPLAY_CLIENT";			}else if (id == REQUEST_REGISTER_CONTROL_CLIENT){				return "REQUEST_REGISTER_CONTROL_CLIENT";			}else if(id == REQUEST_UNREGISTER_CONTROL_CLIENT){				return "REQUEST_UNREGISTER_CONTROL_CLIENT";			}else if(id == RESPONSE_REGISTER_CONTROL_CLIENT){				return "RESPONSE_REGISTER_CONTROL_CLIENT";			}else if(id == RESPONSE_UNREGISTER_CONTROL_CLIENT){				return "RESPONSE_UNREGISTER_CONTROL_CLIENT";			}else if(id == REQUEST_PAYLOAD){				return "REQUEST_PAYLOAD";			}else if(id == RESPONSE_PAYLOAD){				return "RESPONSE_PAYLOAD";			}else {				return "UNKNOWN PACKET"			}		}				public var _id:int;		public var _payload:ByteArray;		public var _magic:ByteArray;				public function RemoteGameInterfacePacket(id:int = 0, payload:ByteArray = null) {			_id = id;			if(payload != null) {				_payload = payload;			}			else {				_payload = new ByteArray();			}			_magic = new ByteArray();			_magic.writeMultiByte(MAGIC, "UTF-8");		}				public function sendToSocket(socket:Socket){			Cc.log("Writing packet " + this);			var firstIdByte:int = 	(_id & 0x00FF0000) >> 16;			var secondIdByte:int = 	(_id & 0x0000FF00) >> 8;			var thirdIdByte:int = 	(_id & 0x000000FF);						socket.writeByte(firstIdByte);			socket.writeByte(secondIdByte);			socket.writeByte(thirdIdByte);						socket.writeBytes(_payload);						socket.writeBytes(_magic);		}				public function toString():String{			var stringResult:String = "[" + getNumberAsHexString(_id) + "][" + _payload + "][" + _magic + "]";			return stringResult;		}				public static function getNumberAsHexString(number:uint, minimumLength:uint = 1, showHexDenotation:Boolean = true):String {			// The string that will be output at the end of the function.      var string:String = number.toString(16).toUpperCase();                      // While the minimumLength argument is higher than the length of the string, add a leading zero.      while (minimumLength > string.length) {      	string = "0" + string;      }                      // Return the result with a "0x" in front of the result.      if (showHexDenotation) { string = "0x" + string; }    	return string;		}				public static function readFromByteArray(byteArray:ByteArray):RemoteGameInterfacePacket {									var firstIdByte:int = byteArray.readByte();			var secondIdByte:int = byteArray.readByte();			var thirdIdByte:int = byteArray.readByte();						var id:int = (firstIdByte & 0x000000FF) << 16;			id |= (secondIdByte & 0x000000FF) << 8;			id |= (thirdIdByte & 0x000000FF);									var payloadByteArray:ByteArray = new ByteArray();			byteArray.readBytes(payloadByteArray, 0, byteArray.length - ID_FIELD_LENGTH - MAGIC_FIELD_LENGTH);						var magicByteArray:ByteArray = new ByteArray();			byteArray.readBytes(magicByteArray, 0, MAGIC_FIELD_LENGTH);						Cc.log("ID(HEX) " + getNumberAsHexString(id));			Cc.log("ID(TYPE) = " + nameOfPacket(id));			Cc.log("PAYLOAD = " + payloadByteArray);			Cc.log("MAGIC = " + magicByteArray);									var packet:RemoteGameInterfacePacket = new RemoteGameInterfacePacket(id,payloadByteArray);			return packet;		}				public static function readFromSocket(socket:Socket):RemoteGameInterfacePacket{			var packet:RemoteGameInterfacePacket = new RemoteGameInterfacePacket();									return packet;		}	}	}